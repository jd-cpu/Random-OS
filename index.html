<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>정형외과 랜덤 Post-test 퀴즈</title>
  <link rel="manifest" href="manifest.json?v=5">
  <meta name="theme-color" content="#4CAF50">
  <style>
    body { font-family: Arial, sans-serif; max-width:800px; margin:20px auto; padding:16px; text-align:center; }
    header { display:flex; justify-content:space-between; align-items:center; gap:12px; }
    h1 { margin:0; font-size:1.25rem; }
    #status { color:#666; font-size:0.95rem; margin-top:8px; text-align:left; }
    .question { margin:20px 0; font-size:1.15rem; white-space:pre-line; text-align:left; }
    .answer { margin-top:10px; font-weight:600; color:#0a6; white-space:pre-line; display:none; text-align:left; }
    .controls { margin-top:18px; }
    button { padding:10px 14px; margin:6px; font-size:1rem; }
    .progress-wrap { margin-top:14px; text-align:left; }
    .progress-info { font-size:0.92rem; color:#444; margin-bottom:6px; }
    .progress-bar { width:100%; height:12px; background:#eee; border-radius:8px; overflow:hidden; }
    .progress-inner { height:100%; width:0%; background:#4caf50; transition: width 0.25s ease; }
    small.note { display:block; color:#888; margin-top:8px; text-align:left; }
  </style>
</head>
<body>
  <header>
    <h1>정형외과 랜덤 Post-test 퀴즈</h1>
    <div>
      <button id="btnToggleMode">복습 모드로</button>
      <button id="btnReset">초기화</button>
    </div>
  </header>

  <div id="status" aria-live="polite">로딩 중...</div>

  <div class="question" id="question">문제가 여기에 표시됩니다.</div>
  <div class="answer" id="answer"></div>

  <div class="controls" id="controls">
    <button id="btnShowAnswer">정답 보기</button>
    <button id="btnMarkWrong">오답 저장</button>
    <button id="btnPrev">이전 문제</button>
    <button id="btnNext">다음 문제</button>
    <!-- 복습 모드에서 첫 문제로 돌아가기 버튼 -->
    <button id="btnRestartReview" style="display:none;">복습 첫 문제로</button>
    <!-- 복습 모드에서 오답 제거 버튼 -->
    <button id="btnRemoveWrong" style="display:none;">오답 제거</button>
  </div>

  <div class="progress-wrap">
    <div class="progress-info" id="progressInfo">진행: 0 / 0 (남음: 0)</div>
    <div class="progress-bar"><div id="progressInner" class="progress-inner"></div></div>
    <small class="note">※ 정답 보기 버튼은 정답만 보여줍니다. 다음 문제로 이동하려면 '다음 문제' 버튼을 누르세요.</small>
  </div>

<script>
  // 기존 문제 데이터
  const questions = [
    { q: "Compartment syndrome의 임상적 소견을 쓰시오(5P sign).", a: "Pain <br>Pallor <br>Paresthesia <br>Pulselessness <br>Paralysis" },
    { q: "어깨 회전근개(Rotator cuff)를 구성하는 4가지 muscle을 쓰시오.", a: "Supraspinatus <br>Infraspinatus <br>Subscapularis <br>Teres minor" },
    { q: "Femur의 atypical fracture의 원인 약제를 쓰시오.", a: "Bisphosphonate" },
    { q: "Carpal tunnel syndrome 관련 신경과 이학적 검사", a: "관련 신경: median nerve <br>이학적 검사: Phalen test, Tinel test, Durkan test" },
    { q: "Cervical myelopathy에서 나타날 수 있는 병적 sign 2가지", a: "UMN lesion sign(ex. hyperreflexia, Babinski sign)" },
    { q: "골관절염(=퇴행성 관절염) 환자의 X-ray 소견의 특징 4가지를 쓰시오.", a: "Asymmetric join space narrowing <br>Osteophyte <br>Subchondral bone sclerosis <br>Subchondral cyst" },
    { q: "Femoral neck Fx. 시 AVN이 잘 생기는 이유는?", a: "Medial femoral circumflex artery 손상에 의한 femur head blood supply 장애 때문" },
    { q: "Carpal tunnel의 구조물을 10가지 쓰시오.", a: "Median nerve(1개), FPL(Flexor pollicis longus) tendon(1개), FDP(Flexor digitorum profundus) tendon(4개), FDS(Flexor digitorum superficialis) tendon(4개)" },
    { q: "Anterior cruciate ligament injury(전방 십자인대 손상)의 이학적 검사법을 쓰시오.", a: "Anterior drawer test, Lachman test, pivot shift test" },
    { q: "5세 여아가 갑작스러운 고관절 통증과 보행장애로 내원했다. X-ray와 혈액검사상 이상 없었으나 의사는 2~3주 후 추적 X-ray를 계획했다. 이때 X-ray는 어떤 질환을 감별하기 위한 것인가?", a: "Legg-Calve-Perthes disease(LCPD)" },
    { q: "FAI(Femoroacetabular impingement)의 종류 및 각 종류별 특징", a: "1) CAM type: femur head와 neck의 junction이 튀어나온 것 <br>2) PINCER type: acetabulum이 femur를 overcoverage하는 경우로, crossover sign을 보임 <br>3) Mixed type: CAM+PINCER type 둘 다 존재하는 경우" },
    { q: "Ulnar nerve의 감각 지배로 옳은 것은? <br><img src='1.png' style='max-width:600px;'> <br><img src='2.png' style='max-width:600px;'> <br><img src='3.png' style='max-width:600px;'> <br><img src='4.png' style='max-width:600px;'>", a: "2)" },
    { q: "2020 endocrine society는 폐경 후 여성에서 골다공증의 치료에 대한 가이드라인을 제시했다. 골다공증의 치료에 사용할 수 있는 수많은 약제 중 2가지를 쓰시오.", a: "Bisphosphonate <br>Denosumab <br>Teriparatide/Abaloparatide <br>Romosozumab" },
    { q: "어떤 nerve의 손상이 winged scapula를 일으키는가?", a: "Long thoracic nerve" }
  ];

  const KEY = {
    WRONG: 'quiz_wrong_v1',
    MODE: 'quiz_mode_v1',
    NORMAL_ORDER: 'quiz_normal_order_v1',
    NORMAL_IDX: 'quiz_normal_idx_v1',
    REVIEW_ORDER: 'quiz_review_order_v1',
    REVIEW_IDX: 'quiz_review_idx_v1'
  };

  let wrongList   = JSON.parse(localStorage.getItem(KEY.WRONG) || '[]');
  let mode        = localStorage.getItem(KEY.MODE) || 'normal';
  let orderNormal = JSON.parse(localStorage.getItem(KEY.NORMAL_ORDER) || 'null');
  let idxNormal   = parseInt(localStorage.getItem(KEY.NORMAL_IDX) || '0', 10);
  let orderReview = JSON.parse(localStorage.getItem(KEY.REVIEW_ORDER) || 'null');
  let idxReview   = parseInt(localStorage.getItem(KEY.REVIEW_IDX) || '0', 10);

  const elStatus          = document.getElementById('status');
  const elQuestion        = document.getElementById('question');
  const elAnswer          = document.getElementById('answer');
  const elBtnShow         = document.getElementById('btnShowAnswer');
  const elBtnWrong        = document.getElementById('btnMarkWrong');
  const elBtnNext         = document.getElementById('btnNext');
  const elBtnPrev         = document.getElementById('btnPrev');
  const elBtnToggle       = document.getElementById('btnToggleMode');
  const elBtnReset        = document.getElementById('btnReset');
  const elProgressInfo    = document.getElementById('progressInfo');
  const elProgressInner   = document.getElementById('progressInner');
  const elBtnRestartReview= document.getElementById('btnRestartReview');
  const elBtnRemoveWrong  = document.getElementById('btnRemoveWrong');

  function shuffledArray(n){
    const arr = Array.from({length:n}, (_,i)=>i);
    for(let i=arr.length-1;i>0;i--){
      const j=Math.floor(Math.random()*(i+1));
      [arr[i],arr[j]]=[arr[j],arr[i]];
    }
    return arr;
  }

  function saveAll(){
    localStorage.setItem(KEY.WRONG, JSON.stringify(wrongList));
    localStorage.setItem(KEY.MODE, mode);
    if(orderNormal) localStorage.setItem(KEY.NORMAL_ORDER, JSON.stringify(orderNormal));
    localStorage.setItem(KEY.NORMAL_IDX, String(idxNormal));
    if(orderReview) localStorage.setItem(KEY.REVIEW_ORDER, JSON.stringify(orderReview));
    localStorage.setItem(KEY.REVIEW_IDX, String(idxReview));
  }

  function clearAll(){
    localStorage.removeItem(KEY.WRONG);
    localStorage.removeItem(KEY.MODE);
    localStorage.removeItem(KEY.NORMAL_ORDER);
    localStorage.removeItem(KEY.NORMAL_IDX);
    localStorage.removeItem(KEY.REVIEW_ORDER);
    localStorage.removeItem(KEY.REVIEW_IDX);
    wrongList = [];
    mode = 'normal';
    orderNormal=null; orderReview=null;
    idxNormal=0; idxReview=0;
  }

  function ensureOrders(skipShuffle=false){
    // ✅ 일반 모드 순서 보장 (기본: 처음 한 번 섞고 고정)
    if(!Array.isArray(orderNormal) || orderNormal.length !== questions.length){
      orderNormal = Array.from({length: questions.length}, (_,i)=>i);
      if(!skipShuffle){
        orderNormal.sort(()=>Math.random()-0.5);
      }
    }

    // ✅ 복습 모드 순서 보장
    if(!Array.isArray(orderReview) || orderReview.length !== wrongList.length){
      orderReview = Array.from({length: wrongList.length}, (_,i)=>i);
    }

    // ✅ 인덱스 보정
    idxNormal = Math.min(Math.max(0, idxNormal), Math.max(0, orderNormal.length-1));
    idxReview = Math.min(Math.max(0, idxReview), Math.max(0, wrongList.length-1));
  }

  function currentListAndIndex(){
    if(mode==='normal'){
      return {listType:'normal', order:orderNormal, idx:idxNormal, total:orderNormal.length};
    } else {
      return {listType:'review', order:orderReview, idx:idxReview, total:orderReview.length};
    }
  }

  function getCurrentQuestion(){
    const info = currentListAndIndex();
    if(info.total===0) return null;
    if(info.listType==='normal'){
      return questions[info.order[info.idx]];
    } else {
      return wrongList[info.order[info.idx]];
    }
  }

  function updateProgressBar(idx,total,percent){
    elProgressInfo.innerText=`진행: ${idx}/${total}  (${percent}%)`;
    elProgressInner.style.width=total===0?'0%':`${percent}%`;
  }

  function updateToggleText(){
    elBtnToggle.textContent = mode==='normal'?`복습 모드 (${wrongList.length})`:'일반 모드로';
  }

  function render(skipShuffle=false){
    ensureOrders(skipShuffle);
    saveAll();
    const info=currentListAndIndex();

    // 버튼 표시
    if(mode==='review' && info.total>0){
      elBtnRestartReview.style.display='inline-block';
      elBtnRemoveWrong.style.display='inline-block';
    } else {
      elBtnRestartReview.style.display='none';
      elBtnRemoveWrong.style.display='none';
    }

    if(info.total===0){
      elStatus.innerText = mode==='normal'? '문제가 비어있습니다. questions 배열을 채워주세요.' : '복습할 문제가 없습니다.';
      elQuestion.innerText = mode==='normal'? '문제가 없습니다.' : '복습할 문제가 없습니다.';
      elAnswer.style.display='none';
      updateProgressBar(0,info.total,0);
      updateToggleText();
      return;
    }

    // 완료 상태
    if(info.idx >= info.total){
      elQuestion.innerText='모든 문제가 완료되었습니다.';
      elAnswer.style.display='none';
      updateProgressBar(info.total, info.total, 100);
      updateToggleText();
      return;
    }

    const cur = getCurrentQuestion();
    if(!cur){
      elQuestion.innerText='문제가 없습니다.';
      elAnswer.style.display='none';
      updateProgressBar(info.idx,info.total,Math.round((info.idx/Math.max(1,info.total))*100));
      updateToggleText();
      return;
    }

    elQuestion.innerHTML = cur.q;
    elAnswer.innerHTML = cur.a;
    elAnswer.style.display='none';

    const currentNumber=info.idx+1;
    const remaining=Math.max(0,info.total-info.idx-1);
    elStatus.innerText=`모드: ${mode==='normal'?'일반':'복습'}  •  ${currentNumber} / ${info.total}  (남음: ${remaining})`;
    updateProgressBar(info.idx, info.total, Math.round((info.idx/Math.max(1,info.total))*100));
    updateToggleText();
  }

  function showAnswer(){
    const cur = getCurrentQuestion();
    if(!cur) return;
    elAnswer.style.display='block';
  }

  function markWrong(){
    const info=currentListAndIndex();
    if(info.total===0 || info.idx>=info.total) return;
    const cur=getCurrentQuestion();
    if(!cur) return;
    if(!wrongList.some(it=>it.q===cur.q && it.a===cur.a)){
      wrongList.push({q:cur.q,a:cur.a});
      orderReview = Array.from({length: wrongList.length}, (_,i)=>i); // 새로 고정
      idxReview=Math.min(idxReview, orderReview.length-1);
      saveAll();
      updateToggleText();
    }
  }

  function removeWrong(){
    const cur = getCurrentQuestion();
    if(!cur) return;
    if(removeFromWrongListByQA(cur.q, cur.a)){
      render();
    }
  }

  function nextQuestion(){
    const info=currentListAndIndex();
    if(info.total===0){ render(); return; }
    if(info.listType==='normal'){
      idxNormal++;
      if(idxNormal>info.total) idxNormal=info.total;
    } else {
      idxReview++;
      if(idxReview>info.total) idxReview=info.total;
    }
    saveAll();
    render();
  }

  function prevQuestion(){
    const info=currentListAndIndex();
    if(info.total===0){ render(); return; }
    if(info.listType==='normal'){
      if(idxNormal<=0) return;
      idxNormal = Math.max(0, idxNormal-1);
      const prev = questions[orderNormal[idxNormal]];
      if(prev) removeFromWrongListByQA(prev.q,prev.a);
    } else {
      if(idxReview<=0) return;
      idxReview=Math.max(0, idxReview-1);
    }
    saveAll();
    render();
  }

  function removeFromWrongListByQA(q,a){
    const i = wrongList.findIndex(it => it.q === q && it.a === a);
    if(i!==-1){
      wrongList.splice(i,1);
      // 순서 재구성 및 인덱스 보정
      orderReview = Array.from({length: wrongList.length}, (_,k)=>k);
      if(idxReview >= wrongList.length){
        idxReview = Math.max(0, wrongList.length - 1);
      }
      saveAll();
      updateToggleText();
      return true;
    }
    return false;
  }

  function restartReview(){
    idxReview=0;
    saveAll();
    render();
  }

  function toggleMode(){
    mode = (mode==='normal')?'review':'normal';
    localStorage.setItem(KEY.MODE, mode);
    if(mode==='review' && wrongList.length===0){
      alert('복습할 오답이 없습니다.');
      mode='normal';
      localStorage.setItem(KEY.MODE, mode);
      return;
    }
    ensureOrders();
    render();
  }

  function resetProgress(){
    if(!confirm('진행 상황(섞인 순서 및 인덱스)과 오답 목록을 초기화할까요?')) return;
    clearAll();
    ensureOrders();
    saveAll();
    render();
  }

  elBtnShow.addEventListener('click', showAnswer);
  elBtnWrong.addEventListener('click', markWrong);
  elBtnNext.addEventListener('click', nextQuestion);
  elBtnPrev.addEventListener('click', prevQuestion);
  elBtnToggle.addEventListener('click', toggleMode);
  elBtnReset.addEventListener('click', resetProgress);
  elBtnRestartReview.addEventListener('click', restartReview);
  elBtnRemoveWrong.addEventListener('click', removeWrong);

  if('serviceWorker' in navigator){
    window.addEventListener('load', ()=>{
      navigator.serviceWorker.register('sw.js?v=5').catch(e=>{
        console.warn('ServiceWorker 등록 실패:', e);
      });
    });
  }

  ensureOrders();
  render();
</script>
</body>
</html>
